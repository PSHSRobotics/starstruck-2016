#pragma config(Sensor, dgtl1,  platformAttached, sensorTouch)
#pragma config(Sensor, dgtl2,  catapultUp,     sensorTouch)
#pragma config(Sensor, dgtl3,  platformSolenoid, sensorDigitalOut)
#pragma config(Sensor, dgtl4,  intake,         sensorDigitalOut)
#pragma config(Motor,  port2,           catapult1,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           catapult2,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           catapult3,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           catapult4,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rDriveBack,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rDriveFront,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           lDriveFront,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lDriveBack,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void setCatapultMotors(int power) {
	motor[catapult1] = power;
  motor[catapult2] = power;
  motor[catapult3] = power;
  motor[catapult4] = power;
}
bool platformReleased = false;
task resetCatapult() {
	setCatapultMotors(-127);

	while(SensorValue[platformAttached]) { //continue to move catapult motors while catapult and platform are attached
		wait1Msec(25);
	}

	while(!SensorValue[platformAttached] || platformReleased) { //...and until the catapult is reattached to the platform
		wait1Msec(25);
	}

	setCatapultMotors(0);
	SensorValue[platformSolenoid] = 0;
	platformReleased = false;
}

bool testMode = false;
task main()
{
	int LY = 0;
	int LX = 0;
	int RY = 0;
	int RX = 0;
	int threshold = 15;
  while(1)
  {
  	//for deadzones; when the joystick value for an axis is below the threshold, the motors controlled by that joystick will not move in that direction
  	LY = (abs(vexRT[Ch3]) > threshold) ? vexRT[Ch3] : 0;
  	LX = (abs(vexRT[Ch4]) > threshold) ? vexRT[Ch4] : 0;
  	RY = (abs(vexRT[Ch2]) > threshold) ? vexRT[Ch2] : 0;
  	RX = (abs(vexRT[Ch1]) > threshold) ? vexRT[Ch1] : 0;
    motor[lDriveFront] = LY + LX;
  	motor[lDriveBack] = LY - LX;
  	motor[rDriveFront] = RY - RX;
  	motor[rDriveBack] = RY + RX;

  	if (!vexRT[Btn7D] && !testMode) {
	  	if(vexRT[Btn5U] == 1)
	  	{
	  		setCatapultMotors(127);
	  	}
	  	else if((vexRT[Btn5D] == 1  && !SensorValue[platformAttached]) || (vexRT[Btn5D] && vexRT[Btn8D]))
	  	{
	  		setCatapultMotors(-127);
	  	}
	  	else
	  	{
	  		setCatapultMotors(0);
	  	}

	  	if (vexRT[Btn6U]) {
	  		SensorValue[platformSolenoid] = 1;
	  	}
	  	if (vexRT[Btn6D]) {
	  		SensorValue[platformSolenoid] = 0;
	  	}

	  	if (vexRT[Btn8U]) {
	  		SensorValue[intake] = 1;
	  	}

	  	if (vexRT[Btn8D]) {
	  		SensorValue[intake] = 0;
	  	}
	  }
  	else { //7D is pressed)
  		//startTask(resetCatapult); //set the catapult motors to -127 to release the catapult and then start moving it down again; this is in a separate task so that the catapult will stop when
  															//	it is supposed to even if the catapultUp condition (below) is never met
  		setCatapultMotors(-127);

  		time1[T1] = 0;
  		while (!SensorValue[catapultUp]/* && time1[T1] < 5000*/) { //wait for catapult to be completely up or up to 5 seconds
  			wait1Msec(25);
  		}

  		wait1Msec(100); //wait a little bit for things to settle out
  		SensorValue[platformSolenoid] = 1; //drop the platform
  		platformReleased = true;

  		wait1Msec(1000); //wait to give time for the platform to fall

  		while(!SensorValue[platformAttached]) { //...and until the catapult is reattached to the platform
				wait1Msec(25);
			}

			setCatapultMotors(0);
			SensorValue[platformSolenoid] = 0;
			platformReleased = false;

  	}
  }

}
