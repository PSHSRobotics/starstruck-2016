#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    catapultPot,    sensorPotentiometer)
#pragma config(Sensor, dgtl1,  drumRatchet,    sensorDigitalOut)
#pragma config(Sensor, dgtl2,  drumPosEnc,     sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  platformDown,   sensorTouch)
#pragma config(Sensor, dgtl5,  drumZero,       sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           lDriveFront,   tmotorVex393HighSpeed_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           lDriveBack,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           rCatapult1,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rCatapult2,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rCatapult3,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lCatapult1,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lCatapult2,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           lCatapult3,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rDriveBack,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rDriveFront,   tmotorVex393HighSpeed_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int UP = 1
const int DOWN = 0;

void setDrumMotors (float power) {
	motor[lCatapult1] = power;
	motor[lCatapult2] = power;
	motor[lCatapult3] = power;
	motor[rCatapult1] = power;
	motor[rCatapult2] = power;
	motor[rCatapult3] = power;
}

void setLeftDtMotors(float power) {
	motor[lDriveFront] = power;
	motor[lDriveBack] = power;
}

void setRightDtMotors(float power) {
	motor[rDriveFront] = power;
	motor[rDriveBack] = power;
}

//if pos is 0(DOWN), the ratchet will be down
//if pos is 1 (UP), the ratchet will be released, which may require moving the catapult down briefly to release the ratchet
void setRatchetPos(int pos) {
	if (pos == 1) {
		setDrumMotors(127)
		wait1Msec(125);
		SensorValue[drumRatchet] = 1;
		setDrumMotors(0);
	} else { //pos == 0
		SensorValue[drumRatchet] = 0;
	}
}

//full rev = 360*7
//automatically releases ratchet first
void moveCatapultDrumDist (int count, int direction) {
	int target;
	if (direction == DOWN) {
		setRatchetPos(DOWN)
		target = SensorValue[drumPosEnc] + count;
		while(SensorValue[drumPosEnc] < count) {
			setDrumMotors(127);
			wait1Msec(25);
		}
	} else { //direction == UP
		//move the catapult down a little to release the ratchet
		setRatchetPos(UP);
		//move drum as requested
		target = SensorValue[drumPosEnc] - count;
		writeDebugStreamLine("%d",target);
		while(SensorValue[drumPosEnc] < count) {
			setDrumMotors(-127);
			wait1Msec(25);
		}
	}
	setDrumMotors(0);
}

// !!!LIFT RATCHET FIRST!!!
void resetDrumPosition() {
	setRatchetPos(1);
	wait1Msec(1000); //one second to make sure the human has lifted the ratchet
	while (!SensorValue[drumZero]) {
		setDrumMotors(127);
	}
	setDrumMotors(0);
}

void runDebugCode() {
	writeDebugStreamLine("Encoder start position: %d",SensorValue[drumPosEnc]);
	moveCatapultDrumDist(DOWN, 340);
	writeDebugStreamLine("Encoder end position: %d",SensorValue[drumPosEnc]);
}

int catapultPositions[3];

bool DEBUG_ENABLE = true;

void catapultInit() {
	catapultPositions[0] = 500;
	catapultPositions[1] = 1000;
	catapultPositions[2] = 1500;
}

task main()
{
	catapultInit();
	//moveCatapultDrumDist(360)
	//int reverse = 1;
	//setDrumMotors(127*reverse);
	//runDebugCode()
	bLCDBacklight = true;
	clearLCDLine(0);
	//if (DEBUG_ENABLE && SensorValue[activateDebug] && false) {
	//	writeDebugStreamLine("Started")
	//	wait1Msec(2000);
	//	SensorValue[drumPosEnc] = 0;
	//	time1[T1] = 0;
	//	writeDebugStreamLine("E: %f, T: %f", SensorValue[drumPosEnc], time1[T1]);
	//	moveCatapultDrumDist(360*14);
	//	} else {
			int LY = 0;
			int LX = 0;
			int RY = 0;
			int RX = 0;
			int threshold = 15;
			while (1) {
				displayLCDNumber(0,1,SensorValue[drumPosEnc],1);
				displayLCDNumber(1,0,SensorValue[drumZero],1);
				if (vexRT[Btn8U]) {
					setDrumMotors(-127);
				} else if (vexRT[Btn8D]) {
					setDrumMotors(127);
				} else {
					setDrumMotors(0);
				}

				if (vexRT[Btn7L] && DEBUG_ENABLE) {
					resetDrumPosition();
				} else if (vexRT[Btn7R] && DEBUG_ENABLE) {
					moveCatapultDrumDist(DOWN,500);
				}


				//for deadzones; when the joystick value for an axis is below the threshold, the motors controlled by that joystick will not move in that direction
				LY = (abs(vexRT[Ch3]) > threshold) ? vexRT[Ch3] : 0;
				LX = (abs(vexRT[Ch4]) > threshold) ? vexRT[Ch4] : 0;
				RY = (abs(vexRT[Ch2]) > threshold) ? vexRT[Ch2] : 0;
				RX = (abs(vexRT[Ch1]) > threshold) ? vexRT[Ch1] : 0;
				motor[lDriveFront] = LY + LX;
				motor[lDriveBack] = LY - LX;
				motor[rDriveFront] = RY + RX;
				motor[rDriveBack] = RY - RX;
				wait1Msec(20);
		//}
	}
}
