#pragma config(Sensor, in1,    arm,            sensorPotentiometer)
#pragma config(Sensor, in2,    claw,           sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  lDriveEnc,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rDriveEnc,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  armDown,        sensorTouch)
#pragma config(Sensor, dgtl6,  liftEnc,        sensorQuadEncoder)
#pragma config(Motor,  port1,           leftClaw,      tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lDriveFront,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           lDriveBack,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           lDump12,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           lDump3,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rDump3,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           rDump12,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rDriveBack,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rDriveFront,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rightClaw,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Competition stuff
// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//global variables
int LEFT = 1; //note that changing this value could affect gyro rotation function if LEFT is used for the value of the direction parameter in that function
int RIGHT = 2;
int AUTON_SIDE = 0; //either LEFT or RIGHT, as above
int AUTON_PLAY = 0;
int armPotOffset = 0; //The value of the claw potentiometer when the claw is fully closed and touching the physical limit
bool LCD_CUBE = true;
bool LCD_STARS = true;

int getArmPos() {
	return SensorValue[claw] - armPotOffset;
}

//Our includes
#include "autonomousLib C.c"
#include "../State/Position PID - 4 Motor Struct.c"
#include "LCD Wizard.c"
//setDumpMotors and setClawMotors are in autonomousLib.c

void pre_auton()
{
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	//bDisplayCompetitionStatusOnLcd = false;

	bLCDBacklight = true;
	//bool testLcdWizard = false;
	//if (bIfiRobotDisabled || testLcdWizard) { //Only show auton play wizard when the robot is in competition mode & disabled on initial startup
	//	startTask(LCDSelect);
	//}
}

//potentiometer value for lift: 2150
task autonomous() {
	//strafeLeft(450,127);
	setClawMotors(-127);
	wait10Msec(135);
	setClawMotors(20);
	SensorValue[rDriveEnc] = 0;
	//wait10Msec(100);
	//while(abs(sensorValue[rDriveEnc]) < 370)
	//{
	//	writeDebugStreamLine("%d",SensorValue[rDriveEnc]);
	//	motor[lDriveFront] = -127;
	//	motor[lDriveBack] = 127;
	//	motor[rDriveFront] = 127;
	//	motor[rDriveBack] = -127;
	//	wait1Msec(25);
	//}
	//motor[lDriveFront] = 0;
	//while(abs(SensorValue[rDriveEnc]) < 300) {
		setLeftDtMotors(127);
		setRightDtMotors(-127);
	//}
	wait1Msec(500);
	setLeftDtMotors(-10);
	setRightDtMotors(10);
	wait1Msec(75);
	setLeftDtMotors(0);
	setRightDtMotors(0);
	wait10Msec(25);
	setRightDtMotors(127);
	setLeftDtMotors(127);
	wait10Msec(120);
	setLeftDtMotors(0);
	setRightDtMotors(0);
	setClawMotors(-50);
	wait10Msec(75);
	//SensorValue[rDriveEnc] = 0;
	//straight(127,1000);
	//setClawMotors(-40);
	//wait10Msec(100);
	setDumpMotors(127);
	wait10Msec(80);
	setDumpMotors(15);
	//SensorValue[rDriveEnc] = 0;
	//wait10Msec(100);
	//while(abs(SensorValue[rDriveEnc]) < 870)
	//{
	//	writeDebugStreamLine("%d",SensorValue[rDriveEnc]);
	//	setRightDtMotors(-127);
	//	setLeftDtMotors(-127);
	//	wait1Msec(25);
	//}
	//SensorValue[rDriveEnc] = 0;
	//wait10Msec(100);
	//while(abs(SensorValue[rDriveEnc]) < 415)
	//{
	//	writeDebugStreamLine("%d",SensorValue[rDriveEnc]);
	//	setRightDtMotors(-85);
	//	setLeftDtMotors(85);
	//	wait1Msec(25);
	//}
	//SensorValue[rDriveEnc] = 0;
	//wait10Msec(100);
	//while(abs(SensorValue[rDriveEnc]) < 870)
	//{
	//	writeDebugStreamLine("%d",SensorValue[rDriveEnc]);
	//	setRightDtMotors(-127);
	//	setLeftDtMotors(-127);
	//	wait1Msec(25);
	//}
	//liftToPotTarget(1100,127);
	//setClawMotors(127);
	//wait10Msec(200);
	//setClawMotors(0);
	wait10Msec(25);
	setRightDtMotors(-127);
	setLeftDtMotors(-127);
	wait10Msec(120);
	setLeftDtMotors(0);
	setRightDtMotors(0);
	setLeftDtMotors(127);
		setRightDtMotors(-127);
	//}
	wait1Msec(347);
	setLeftDtMotors(-10);
	setRightDtMotors(10);
	wait1Msec(75);
	setLeftDtMotors(0);
	setRightDtMotors(0);
	wait10Msec(25);
	setRightDtMotors(-127);
	setLeftDtMotors(-127);
	wait10Msec(155);
	setLeftDtMotors(0);
	setRightDtMotors(0);
	setDumpMotors(127);
	wait10Msec(80);
	setDumpMotors(0);
	setClawMotors(127);
	wait10Msec(75);
	setClawMotors(15);
}

task usercontrol()
{
	//wait10Msec(100);
	//startTask(autonomous);
	//stopTask(usercontrol);
	//stopTask(main);

	//setClawMotors(127);
	//wait1Msec(750);
	//setClawMotors(-127);
	//wait1Msec(400);
	int LY = 0;
	int LX = 0;
	int RY = 0;
	int RX = 0;
	int threshold = 15;
	int armCompPower = 12; //compensation power for arm/lift
	int armPotMaxLimit = 400; //software limit for potentiometer to limit arm movement from going over the top (protects potentiometer)
	bool enableSoftwareArmPosLimit = true; //experimental software limit for arm, see above
	int clawCompPower = 15;
  while(1)
  {
  	/*if (vexRT[Btn8u]){
  		startTask(autonomous);
  		stopTask(usercontrol);
  	}*/
  	//for deadzones; when the joystick value for an axis is below the threshold, the motors controlled by that joystick will not move in that direction
  	LY = (abs(vexRT[Ch3]) > threshold) ? vexRT[Ch3] : 0;
  	LX = (abs(vexRT[Ch4]) > threshold) ? vexRT[Ch4] : 0;
  	RY = (abs(vexRT[Ch2]) > threshold) ? vexRT[Ch2] : 0;
  	RX = (abs(vexRT[Ch1]) > threshold) ? vexRT[Ch1] : 0;
    motor[lDriveFront] = LY + LX;
  	motor[lDriveBack] = LY - LX;
  	motor[rDriveFront] = RY - RX;
  	motor[rDriveBack] = RY + RX;

  	//untested
	  if (vexRT[Btn5U] && (SensorValue[arm] > armPotMaxLimit || !enableSoftwareArmPosLimit)) {
	  	setDumpMotors(127);
		} else if (vexRT[Btn5D]) { //second part of condition is to prevent motors from jittering if 5U and 5D are pressed down
			setDumpMotors(-127);
		} else {
			if (SensorValue[arm] > 3780) { //arm is all the way down; no compensation power
				setDumpMotors(0);
			} else if (SensorValue[arm] > 1180) { //arm is up but has not gone past vertical (behind back of robot).  Positive compensation power
				setDumpMotors(armCompPower);
			} else { //arm is up and behind the back of the robot.  Negative compensation power (and increased compensation power to protect potentiometer from crossing its physical limit and counter momentum)
				setDumpMotors(-armCompPower);
			}
		}

  	if (vexRT[Btn6U]) {
			setClawMotors(127);
			clawCompPower = 15;
		} else if (vexRT[Btn6D]) {
			setClawMotors(-127);
			clawCompPower = -20;
		}	else {
			setClawMotors(clawCompPower);
		}

  	wait1Msec(25);
	}
}
