#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  catLimSwitch,   sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightCatMiddle, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightCatFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightCatBack,  tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port4,           FL,            tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_6)
#pragma config(Motor,  port5,           FR,            tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port6,           BR,            tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           BL,            tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port8,           leftCatFront,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftCatBack,   tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_5)
#pragma config(Motor,  port10,          leftCatMiddle, tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "..\Vex_Competition_Includes.c"
#include "LCD Selection Wizard.c"
//#include "Position PID.c"

/*------------------------------------------------------


Motion / Mechanics Notes

Entire left side is reversed so that robot can go forward
List (FL Speed, BL speed, BR speed, FR) - remember FL and BL are reversed
Forward: 127, 127, 127, 127 - both joysticks forward
Backwards: -127, -127, -127, -127 - both joysticks backwards
Strafe Left: -127, 127, 127, -127 - both joysticks left
Strafe Right: 127, -127, -127, 127 - both joysticks right
Rotate Left: -127, -127, 127, 127 - left joystick down right joystick up
Rotate Right: 127, 127, -127,-127 - left joystick up right joystick down

Controls -

6D/6U - arms go up/down
5D/5U - arm hooks rotate
8C - wind down catapult
8D - release catapult
*Possible* - 7D - extend hook // 7L - retract hook

------------------------------------------------------*/
// Speed Values
float encoderAverage = 0; //establishes encoderAverage as 0;
const int threshold = 15; //establishes deadzone for joystick so that XDRIVE motors don't stall
int catPower = 127; //power to the catapult motors

//Misc Value Holders
int restTime = 800;


void zeroEncoders(){ //zeros all of the motor encoders for new maneuvers
	nMotorEncoder[BL] = 0;
	nMotorEncoder[BR] = 0;
	nMotorEncoder[FL] = 0;
	nMotorEncoder[FR] = 0;
	nMotorEncoder[leftCatBack] = 0;
	nMotorEncoder[rightCatBack] = 0;

}

void setDrivePower(int frontLeft, int frontRight, int backLeft, int backRight){ //function for easily controlling drivetrain motor power
	motor[FL] = frontLeft;
	motor[FR] = frontRight;
	motor[BR] = backRight;
	motor[BL] = backLeft;


}

float getDriveEncoderAverage(){
	encoderAverage = (abs(nMotorEncoder[BL]) + abs(nMotorEncoder[BR]) + abs(nMotorEncoder[FL]) + abs(nMotorEncoder[FR]))/4;
	return encoderAverage;

}

void setCatapultPower(int power){
	motor[leftCatBack] = power;
	motor[leftCatFront] = power;
	motor[rightCatFront] = power;
	motor[rightCatBack] = power;
	motor[leftCatMiddle] = power;
	motor[rightCatMiddle] = power;

}

void driveCatTime(int power, int time){
	motor[rightCatFront] = power;
	motor[rightCatBack] = power;
	motor[leftCatFront] = power;
	motor[leftCatBack] = power;
	motor[leftCatMiddle] = power;
	motor[rightCatMiddle] = power;
	wait1Msec(time);

}

/*----------------------------------------------------------------------------------------------------------

Maneuver Functions (for autonomous) - encoder based

----------------------------------------------------------------------------------------------------------*/

void forward(int power, int counts){//FL, FR, BR, BL
	zeroEncoders();
	while( getDriveEncoderAverage() < counts){
		setDrivePower(127, 127,127,127);
		/*if (nMotorEncoder[BL] > counts){motor[BL] = 0;}
		else if (nMotorEncoder[BR] > counts){motor[BR] = 0}
		else if (nMotorEncoder[FL] > counts){motor[Fl] = 0;}
		else if (nMotorEncoder[FR] > counts){motor[FR] = 0;}*/

	}
}

void backwards(int power, int counts){//FL, FR, BR, BLzeroEncoders();
	while( getDriveEncoderAverage() < counts){
		getDriveEncoderAverage();
		setDrivePower(-127, -127,-127,-127);
	}
}

void strafeLeft(int power, int counts){//FL, FR, BR, BL
	zeroEncoders();
	while(getDriveEncoderAverage() < counts){
		setDrivePower(-127, 127, 127, -127);
	}
}

void strafeRight(int power, int counts){//FL, FR, BR, BL
	zeroEncoders();
	while(getDriveEncoderAverage() < counts){

		setDrivePower(127, -127, -127, 127);
	}
}

void rotate (int power, int counts, int direction){
	if(sgn(direction) == 1){//means that the direction is clockwise
		zeroEncoders();
		while(getDriveEncoderAverage() < counts){//FL, FR, BR, BL
			setDrivePower(-127, 127, 127, -127);

		}

	}
	else if (sgn(direction) == -1){//means the direction is counterclockwise
		zeroEncoders();
		while(getDriveEncoderAverage() < counts){//FL, FR, BR, BL
			setDrivePower(127, -127, -127, 127);

		}
	}
}

void doThaShimmy(){
	int shimmyCounts = 25;
	backwards(127, shimmyCounts);
	forward(127, shimmyCounts);
	backwards(127, shimmyCounts);
	forward(127, shimmyCounts);
	backwards(127, shimmyCounts);
	forward(127, shimmyCounts);
	backwards(127, shimmyCounts);
	forward(127, shimmyCounts);
	backwards(127, shimmyCounts);
	forward(127, shimmyCounts);
	backwards(127, shimmyCounts);
	forward(127, shimmyCounts);
	setDrivePower(0,0,0,0);


}
void rotCatExact(int power, int counts, int direction){
	if(sgn(direction) == 1){//means down
		zeroEncoders();
		while(getDriveEncoderAverage() < counts){//FL, FR, BR, BL
			setCatapultPower(127);
		}
	}
	else if (sgn(direction) == -1){//means pull her up
		zeroEncoders();
		while(getDriveEncoderAverage() < counts){//FL, FR, BR, BL
			setCatapultPower(-127);
		}
	}
}

/*----------------------------------------------------------------------------------------------------------

Miscellaneous Functions - Cutting Motors, resets, etc.

----------------------------------------------------------------------------------------------------------*/
void cutMotors(){
	setDrivePower(0,0,0,0);
	setCatapultPower(0);

}
//Rest Time Functions
void rest(){
	wait1Msec(restTime);
}

void cutAndRest(){
	rest();
	cutMotors();
}

void driveViaTime(string direction,int speed, int time){
	if(direction == "forward"){
		setDrivePower(speed, speed, speed, speed);
		wait1Msec(time);
	}
	else if (direction == "strafeLeft"){
		setDrivePower(-speed, speed, -speed, speed);
		wait1Msec(time);
	}
	else if (direction == "strafeRight"){
		setDrivePower(speed, -speed, speed, -speed);
		wait1Msec(time);
	}
	else if (direction == "backwards"){
		setDrivePower(-speed, -speed, -speed, -speed);
		wait1Msec(time);

	}

}

/*************TASK***********************/

task catapult () { //task to run the catapult motors at the same time as the drivetrain
	while(true){
		if(vexRT[Btn5U] == 1){ //temporary drive controls
			setCatapultPower(catPower);
		}
		else if (vexRT[Btn5D] == 1 && SensorValue[catLimSwitch] == 0){
			setCatapultPower(-catPower);
		}
		else if(SensorValue[catLimSwitch] == 1 && vexRT[Btn5D] == 1){
			setCatapultPower(0);
			wait1Msec(100);

		}
		else if (vexRT[Btn8R] == 1){ //ignores button and launches catapult
			setCatapultPower(127);
			wait1Msec(850);

		}
		else {
			setCatapultPower(0);
		}
	}
}
task autonFenceRight (){ //can be used on all
	//Shimmy Dance
			doThaShimmy();
			wait1Msec(50);
			rotCatExact(127, 500, -1);
			setDrivePower(127,127,127,127); //drive forward
			wait1Msec(1400);
			setDrivePower(0,0,0,0);
			wait1Msec(500);
			strafeRight(127, 800);
			setDrivePower(0,0,0,0);

}
task autonFenceLeft(){
	doThaShimmy();
			wait1Msec(50);
			rotCatExact(127, 500, -1);
			setDrivePower(127,127,127,127); //drive forward
			wait1Msec(1400);
			setDrivePower(0,0,0,0);
			wait1Msec(500);
			strafeLeft(127, 800);
			setDrivePower(0,0,0,0);

}
task autonGoodPlay(){


}

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	zeroEncoders();
	bDisplayCompetitionStatusOnLcd = false;
	bLCDBacklight = true;

	startTask(lcdSelection);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	/* ..........................................................................

	Autonomous Oveview:

	-Start facing the two stars at the center, back of the field

	1.Back up for 1/2 second then forward 1/2 second - we call this the "shimmy" - it deploys platform
	2.3/4 Seconds forward to get stars
	3. Use 1/2 seconds to lift catapult slightly to prevent stars from falling out in transit
	4. Move back 3/4 seconds
	5. Strafe right for 2 seconds or until close to fence and clear of cube
	6. Turn 90 degrees counter-clockwise
	7. 1/2 Seconds for remaining catapult down and then fire 1/2 second
	8. Turn 160 degrees (enough to bump stars off fence)counterclockwise and knock stars off
	9. Turn 70 degrees clockwise, move forward, then turn counterclockwise again and knock more stars off fence
	10. End Autonomous


	// ..........................................................................*/

	// Remove this function call once you have "real" code.
	//Play One
		if (autonChoices.waitTime > 0) {
		wait1Msec(autonChoices.waitTime*1000);
	}

	if (autonChoices.startingTile == "left") {
			startTask(autonFenceLeft);
	} else if (autonChoices.startingTile == "right") {
			startTask(autonFenceRight);
	} else if (autonChoices.startingTile == "programmingSkills") {

	}

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	// User control code here, inside the loop

	//Assign some starter values to the four movement integers
	int LY = 0;
	int LX = 0;
	int RY = 0;
	int RX = 0;

	while(true )
	{
		startTask(catapult);
		/*
		Ternary Statement: value = (true boolean) ? (false boolean) : value
		If the absolute value of one of these vexRT Channels is greater than the threshold, assign the value
		If it is NOT greater than threshold, make it 0
		*/
		LX = (abs(vexRT[Ch4]) > threshold) ? vexRT[Ch4] : 0;
		LY = (abs(vexRT[Ch3]) > threshold) ? vexRT[Ch3] : 0;
		RY = (abs(vexRT[Ch2]) > threshold) ? vexRT[Ch2] : 0;
		RX = (abs(vexRT[Ch1]) > threshold) ? vexRT[Ch1] : 0;

		motor[FL] = LY + LX;
		motor[FR] = RY - RX;
		motor[BR] = RY + RX;
		motor[BL] = LY - LX;

		wait1Msec(25); // gives computer time to run code in other tasks
	}
}
