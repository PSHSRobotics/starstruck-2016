#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightCatFront, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightCatBack,  tmotorVex393_HBridge, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port4,           FL,            tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_6)
#pragma config(Motor,  port5,           FR,            tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port6,           BR,            tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           BL,            tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port9,           leftCatFront,  tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port10,          leftCatBack,   tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_5)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Speed Values
const int threshold = 15; //minimum joystick value
int inputValueButtons = 0;
int catPower = 85;
float encoderAverage = 0;

//Rotational Values

void zeroEncoders(){ //zeros all of the motor encoders for new maneuvers
	nMotorEncoder[BL] = 0;
	nMotorEncoder[BR] = 0;
	nMotorEncoder[FL] = 0;
	nMotorEncoder[FR] = 0;
	nMotorEncoder[leftCatBack] = 0;
	nMotorEncoder[rightCatBack] = 0;

}

void setDrivePower(int frontLeft, int frontRight, int backLeft, int backRight){
	motor[FL] = frontLeft;
	motor[FR] = frontRight;
	motor[BR] = backRight;
	motor[BL] = backLeft;


}

float getDriveEncoderAverage(){
	encoderAverage = (abs(nMotorEncoder[BL]) + abs(nMotorEncoder[BR]) + abs(nMotorEncoder[FL]) + abs(nMotorEncoder[FR]))/4;
	return encoderAverage;

}

void setCatapultPower(int power){ //function that sets the power for catapult motors (real quick and easy)
	motor[rightCatFront] = power;
	motor[rightCatBack] = power;
	motor[leftCatFront] = power;
	motor[leftCatBack] = power;

}

//Maneuver Functions (for autonomous)

void forward(int power, int counts){//FL, FR, BR, BL
	zeroEncoders();
	while( encoderAverage < counts){
		getDriveEncoderAverage();
		setDrivePower(127, 127,127,127);
	}



}

void strafeLeft(int power, int counts){//FL, FR, BR, BL
	zeroEncoders();
	while(encoderAverage < counts){
		getDriveEncoderAverage();
		setDrivePower(-127, 127, 127, -127);
	}
}

void strafeRight(int power, int counts){//FL, FR, BR, BL
	zeroEncoders();
	while(encoderAverage < counts){
		getDriveEncoderAverage();
		setDrivePower(127, -127, -127, 127);
	}
}

void rotate (int power, int counts, int direction){
	if(sgn(direction) == 1){//means that the direction is clockwise
		zeroEncoders();
		while(encoderAverage < counts){//FL, FR, BR, BL
			setDrivePower(-127, 127, 127, -127);

		}

	}
	else if (sgn(direction) == -1){//means the direction is counterclockwise
		zeroEncoders();
		while(encoderAverage < counts){//FL, FR, BR, BL
			setDrivePower(127, -127, -127, 127);

		}
	}
}


task catapult () { //task to run the catapult motors at the same time as the drivetrain
	while(true){
		if(vexRT[Btn5U] == 1){ //temporary drive controls
			setCatapultPower(catPower);
		}
		else if (vexRT[Btn5D] == 1){
			setCatapultPower(-catPower);
		}
		else {
			setCatapultPower(0);
		}
	}
}

task main()
{



}
