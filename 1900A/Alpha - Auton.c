#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightCatFront, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightCatBack,  tmotorVex393_HBridge, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port4,           FL,            tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_6)
#pragma config(Motor,  port5,           FR,            tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port6,           BR,            tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           BL,            tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port9,           leftCatFront,  tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port10,          leftCatBack,   tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_5)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Speed Values
float encoderAverage = 0;

//Rotational Values

void zeroEncoders(){ //zeros all of the motor encoders for new maneuvers
	nMotorEncoder[BL] = 0;
	nMotorEncoder[BR] = 0;
	nMotorEncoder[FL] = 0;
	nMotorEncoder[FR] = 0;
	nMotorEncoder[leftCatBack] = 0;
	nMotorEncoder[rightCatBack] = 0;

}

void setDrivePower(int frontLeft, int frontRight, int backLeft, int backRight){ //function for easily controlling drivetrain motor power
	motor[FL] = frontLeft;
	motor[FR] = frontRight;
	motor[BR] = backRight;
	motor[BL] = backLeft;


}

float getDriveEncoderAverage(){
	encoderAverage = (abs(nMotorEncoder[BL]) + abs(nMotorEncoder[BR]) + abs(nMotorEncoder[FL]) + abs(nMotorEncoder[FR]))/4;
	return encoderAverage;

}

void setCatapultPower(int power){ //function that sets the power for catapult motors (real quick and easy)
	motor[rightCatFront] = power;
	motor[rightCatBack] = power;
	motor[leftCatFront] = power;
	motor[leftCatBack] = power;

}

//Maneuver Functions (for autonomous)

void forward(int power, int counts){//FL, FR, BR, BL
	zeroEncoders();
	while( getDriveEncoderAverage() < counts){
		setDrivePower(127, 127,127,127);
	}
}

void backwards(int power, int counts){//FL, FR, BR, BL
	zeroEncoders();
	while( getDriveEncoderAverage() < counts){
		getDriveEncoderAverage();
		setDrivePower(-127, -127,-127,-127);
	}
}

void strafeLeft(int power, int counts){//FL, FR, BR, BL
	zeroEncoders();
	while(getDriveEncoderAverage() < counts){
		setDrivePower(-127, 127, 127, -127);
	}
}

void strafeRight(int power, int counts){//FL, FR, BR, BL
	zeroEncoders();
	while(getDriveEncoderAverage() < counts){

		setDrivePower(127, -127, -127, 127);
	}
}

void rotate (int power, int counts, int direction){
	if(sgn(direction) == 1){//means that the direction is clockwise
		zeroEncoders();
		while(getDriveEncoderAverage() < counts){//FL, FR, BR, BL
			setDrivePower(-127, 127, 127, -127);

		}

	}
	else if (sgn(direction) == -1){//means the direction is counterclockwise
		zeroEncoders();
		while(getDriveEncoderAverage() < counts){//FL, FR, BR, BL
			setDrivePower(127, -127, -127, 127);

		}
	}
}

void doThaShimmy(){
	backwards(127, 250);
	forward(127, 250);
	backwards(127, 250);
	forward(127, 250);

}
void rotCatExact(int power, int counts, int direction){
	if(sgn(direction) == 1){//means down
		zeroEncoders();
		while(getDriveEncoderAverage() < counts){//FL, FR, BR, BL
			setCatapultPower(127);
		}
	}
	else if (sgn(direction) == -1){//means pull her up
		zeroEncoders();
		while(getDriveEncoderAverage() < counts){//FL, FR, BR, BL
			setCatapultPower(-127);
		}
	}
}
task main()
{
	/*---------------------------------------
	Play One: Move forward and get three stars, lift up platform to secure stars, move back to clear cube,
	strafe right until almost touching fence. Rotate 90 degrees counter-clockwise and launch stars. Turn 160
	degrees counterclockwise to knock stars off fence. Assuming three far zone stars and two close stars, we get

	Total: 8 points + possible autonomous bonus

	Play Two:
	Do the shimmy, back up, strafe right, then move forward to get cube, lift cube up, rotate 90 degrees
	counter-clockwise and fire cube. Rotate 160ish degrees to knocks stars off

	Total: 6 points + autonomous bonus
	---------------------------------------*/

	//Play One

	//Shimmy Dance
	doThaShimmy();
	forward(127, 1350); // get stars
	rotCatExact(127, 500, -1); //pull catapult up a little bit to save stars
	backwards(127, 1400); //goes backward to clear cube
	strafeRight(127, 1900); //strafe right to get to the fence
	rotate(127, 500, -1); //rotate to get into firing position
	rotCatExact(127, 600, 1); //fire catapult
	rotate(127, 750, -1); //rotate to knock off stars




}
