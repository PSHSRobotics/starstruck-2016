#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    AutonSelector,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  DRFLED1,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  DRFRED1,        sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  DRBRED1,        sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  DRBLED1,        sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  plfmStop,       sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           LLM,           tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           FR,            tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           FL,            tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LFBB,          tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LFBT,          tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port6,           RFBB,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           RFBT,          tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port8,           RLM,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           BR,            tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          BL,            tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void setLiftMotors(int speed){
	motor[LLM] = speed;
	motor[RLM] = speed;
}

//Switch Cases
const int forward = 1;
const int turnRight = 2;
const int turnLeft = 3;
const int backwards = 4;
const int up = 5;
const int down= 6;

const int wt =950;
const int fbs = 40;
const	float tsp = 80;
const	int fbbs = 20;

//Encoder Variables
float wheelCircumference = 3.25*PI;
float revolutions = 0;
float averageEncoderValue = 0;
int speedMCounts = 392; //number of counts per rotation for VEX High Speed Motor

void zeroEncoders(){ //Zeros Encoders
	SensorValue[DRFLED1] = 0;
	SensorValue[DRFRED1] = 0;
	SensorValue[DRBRED1] = 0;
	SensorValue[DRBLED1] = 0;
	nMotorEncoder(LFBT) = 0;
	nMotorEncoder(RFBT) = 0;
}
void setFBMotors(int speed){ //automatically sets the four bar power (reduce clutter)
	motor[RFBT] = speed;
	motor[RFBB] = speed;
	motor[LFBT] = speed;
	motor[LFBB] = speed;

}

void setDriveMotors(int FLSpeed, int FRspeed, int BRspeed, int BLspeed){ //int FLSpeed, int FRspeed, int BRspeed, int BLspeed
	motor[FL] = FLspeed;
	motor[FR] = FRspeed;
	motor[BR] = BRspeed;
	motor[BL] = BLspeed;
}

void Break(int direction){
	switch (direction) {
	case forward:
		setDriveMotors(-127,-127,-127,-127);
		wait10Msec(7);
		break;

	case turnLeft:
		setDriveMotors(127, -127, -127, 127);
		wait10Msec(7);
		break;

	case turnRight:
		setDriveMotors(-127, 127, 127, -127);
		wait10Msec(7);
		break;

	case backwards:
		setDriveMotors(127,127,127,127);
		wait10Msec(7);
		break;

	default:
		setDriveMotors(0,0,0,0);
	}
}
float getDTEncoderAverage(){
	averageEncoderValue = (abs(SensorValue(DRFLED1)) + abs(SensorValue(DRFRED1)) + abs(SensorValue(DRBRED1)) + abs(SensorValue(DRBLED1)))/4;
	return averageEncoderValue;
}
float getFBEncoderAverage(){
	float average = (abs(nMotorEncoder[LFBT]) + abs(nMotorEncoder[RFBT])) / 2;
	return average;
}
void moveFB(int direction, int ticks, int speed){
	zeroEncoders();
	float wt = 2;
	if(direction == up){
		while(getFBEncoderAverage() < ticks){
			if (getFBEncoderAverage() == ticks - 100 && speed != 127){
				setFBMotors(speed - 20);
			}
			else {
				setFBMotors(speed);
			}
		}
		setFBMotors(-127);
		wait10Msec(wt);
	}
	else if(direction == down){
		while(getFBEncoderAverage() < ticks){
			if (getFBEncoderAverage() == ticks - 100){
				setFBMotors(speed + 20);
			}
			else {
				setFBMotors(-speed);
			}

		}
		setFBMotors(127);
		wait10Msec(wt);
	}
	else {
		setFBMotors(0);
	}
}
void move(int direction, int speed, int distance, int FBbreakspd){
	revolutions = 360*(distance/wheelCircumference);
	switch (direction) {

	case forward:
		zeroEncoders();
		while(getDTEncoderAverage() < revolutions){
			setDriveMotors(127,127,127, 127);
			setFBMotors(FBbreakspd);
		}
		zeroEncoders();
		Break(forward);
		break;

	case turnLeft: //int FLSpeed, int FRspeed, int BRspeed, int BLspeed
		zeroEncoders();
		while(getDTEncoderAverage() < revolutions){
			setDriveMotors(-127, 127, 127, -127);
			setFBMotors(FBbreakspd);

		}
		Break(turnLeft);
		break;

	case turnRight: //int FLSpeed, int FRspeed, int BRspeed, int BLspeed
		zeroEncoders();
		while(getDTEncoderAverage() < revolutions){
			setDriveMotors(127, -127, -127, 127);
			setFBMotors(FBbreakspd);
		}
		Break(turnRight);
		break;

	case backwards:
		zeroEncoders();
		while(getDTEncoderAverage() < revolutions){
			setDriveMotors(-127, -127, -127, -127);
			setFBMotors(FBbreakspd);

		}
		Break(backwards);
		break;

	default:
		setDriveMotors(0,0,0,0);
		zeroEncoders();

	}
	zeroEncoders();
}
void encoderTest(int ticks){
	zeroEncoders();
	while(getDTEncoderAverage() < ticks){
		setDriveMotors(127,127,127, 127);
	}
}
task FBControl(){ //task for the Four-Bar control
	while(true){
		//Four-Bar Motor Controls (2 bottom motors on either side are y-cabeled FYI
		if (vexRT[Btn6U] == 1 && vexRT[Btn6D] == 0){ //UP
			setFBMotors(127);
		}
		else if (vexRT[Btn6U] == 0 && vexRT[Btn6D] == 1){ //DOWN
			setFBMotors(-127);
		}
		else { //IDLE
			setFBMotors(0);
		}
	}
}

task liftControl (){//task for the lift control
	bool hasBeenPressed = false;
	while(true){
		if(vexRT[Btn5U] == 1 && vexRT[Btn5D] == 0){
			setLiftMotors(127);
			hasBeenPressed = true;
		}
		else if (vexRT[Btn5U] == 0 && vexRT[Btn5D] == 1){
			setLiftMotors(-127);
			hasBeenPressed = true;
		}
		else if (hasBeenPressed = false) {
			setLiftMotors(0);
		}
		else {
			setLiftMotors(10);
		}
	}
}
task main()
{
	// User control code here, inside the loop
	startTask(FBControl);
	startTask(liftControl);
	while (true)
	{
		//Drivetrain controls and threshold (15)
		//Need to convert ternary statements at some point or another
		motor[FL] = vexRT[Ch3];
		motor[BL] = vexRT[Ch3];
		motor[FR] = vexRT[Ch2];
		motor[BR] = vexRT[Ch2];
	}


}
